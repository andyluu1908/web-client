// Generated by typings
// Source: typings/relay-runtime.d.ts
declare module 'relay-runtime' {
  /** Declaration file generated by dts-gen */

  import * as React from 'react'
  import * as ReactRelay from 'react-relay'

  module 'relay-runtime' {
    interface Network {
      fetch: any
      request: any
      requestStream: any
    }

    export namespace Network {
      export function create(fetch: any, subscribe?: any): Network
    }
  }

  type Record = { [key: string]: any }

  type DataID = string
  type Variables = { [name: string]: any }
  type HandleFieldPayload = {
    // The arguments that were fetched.
    args: Variables
    // The __id of the record containing the source/handle field.
    dataID: DataID
    // The (storage) key at which the original server data was written.
    fieldKey: string
    // The name of the handle.
    handle: string
    // The (storage) key at which the handle's data should be written by the
    // handler.
    handleKey: string
  }
  type Handler = {
    update: (store: RecordSourceProxy, fieldPayload: HandleFieldPayload) => void
  }
  type HandlerProvider = (name: string) => Handler

  type EnvironmentConfig = {
    handlerProvider?: HandlerProvider
    network: Network
    store: Store
  }

  export class Environment {
    constructor(config: EnvironmentConfig)

    getStore: () => Store
  }

  export class QueryResponseCache {
    constructor(_ref: any)

    clear(): void

    get(queryID: any, variables: any): any

    set(queryID: any, variables: any, payload: any): void
  }

  export class RecordSource {
    constructor(records?: ReactRelay.RecordMap)

    clear(): void

    delete(dataID: any): void

    get(dataID: any): any

    getRecordIDs(): any

    getStatus(dataID: any): any

    has(dataID: any): any

    load(dataID: any, callback: any): void

    remove(dataID: any): void

    set(dataID: any, record: any): void

    size(): any

    toJSON(): any
  }

  export class RecordSourceInspector {
    constructor(source: any)

    get(dataID: any): any

    getNodes(): any

    getRecords(): any

    getRoot(): any
  }

  export class Store {
    constructor(source: any)

    check(selector: any): any

    getSource(): any

    lookup(...args: any[]): any

    notify(...args: any[]): any

    publish(...args: any[]): any

    resolve(target: any, selector: any, callback: any): void

    retain(...args: any[]): any

    subscribe(...args: any[]): any
  }

  export function areEqualSelectors(thisSelector: any, thatSelector: any): any

  export function commitLocalUpdate(environment: any, updater: any): void

  export function commitMutation(environment: any, config: any): any

  export function createFragmentSpecResolver(
    context: any,
    containerName: any,
    fragments: any,
    props: any,
    callback: any
  ): any

  export function createOperationSelector(operation: any, variables: any): any

  export function fetchQuery(
    environment: any,
    taggedNode: any,
    variables: any,
    cacheConfig: any
  ): any

  export function getDataIDsFromObject(fragments: any, object: any): any

  export function getFragment(taggedNode: any): any

  export function getOperation(taggedNode: any): any

  export function getSelector(
    operationVariables: any,
    fragment: any,
    item: any
  ): any

  export function getSelectorList(
    operationVariables: any,
    fragment: any,
    items: any
  ): any

  export function getSelectorsFromObject(
    operationVariables: any,
    fragments: any,
    object: any
  ): any

  export function getVariablesFromObject(
    operationVariables: any,
    fragments: any,
    object: any
  ): any

  export function graphql(strings: any): void

  export function isRelayModernEnvironment(environment: any): any

  export function requestSubscription(
    environment: any,
    config: any,
    ...args: any[]
  ): any

  interface RecordSourceSelectorProxy {
    create(dataID: DataID, typeName: string): RecordProxy
    delete(dataID: DataID): void
    get(dataID: DataID): RecordProxy
    getRoot(): RecordProxy
    getRootField(fieldName: string): RecordProxy
    getPluralRootField(fieldName: string): [RecordProxy] | void
  }

  interface RecordProxy {
    copyFieldsFrom(source: RecordProxy): void
    getDataID(): DataID
    getLinkedRecord(name: string, args?: Variables): RecordProxy
    getLinkedRecords(name: string, args?: Variables): RecordProxy
    getOrCreateLinkedRecord(
      name: string,
      typeName: string,
      args?: Variables
    ): RecordProxy
    getType(): string
    getValue(name: string, args?: Variables): any
    setLinkedRecord(
      record: RecordProxy,
      name: string,
      args?: Variables
    ): RecordProxy
    setLinkedRecords(
      records: [RecordProxy],
      name: string,
      args?: Variables
    ): RecordProxy
    setValue(value: any, name: string, args?: Variables): RecordProxy
  }

  interface RecordSourceProxy {
    create(dataID: DataID, typeName: string): RecordProxy
    delete(dataID: DataID): void
    get(dataID: DataID): RecordProxy
    getRoot(): RecordProxy
  }

  interface RecordSource {
    get(dataID: DataID): Record | void
    getRecordIDs(): Array<DataID>
    getStatus(dataID: DataID): any
    has(dataID: DataID): boolean
    load(
      dataID: DataID,
      callback: (error: Error | void, record: Record | void) => void
    ): void
    size(): number
  }

  export namespace ConnectionHandler {
    function createEdge(
      store: RecordSourceProxy,
      record: RecordProxy,
      node: RecordProxy,
      edgeType: string
    ): RecordProxy

    function deleteNode(record: RecordProxy, nodeID: DataID): void

    function getConnection(
      record: RecordProxy,
      key: string,
      filters?: Variables
    ): any

    function insertEdgeAfter(
      record: RecordProxy,
      newEdge: RecordProxy,
      cursor?: string
    ): void

    function insertEdgeBefore(
      record: RecordProxy,
      newEdge: RecordProxy,
      cursor?: string
    ): void

    function update(store: RecordSourceProxy, payload: HandleFieldPayload): void
  }

  export namespace ViewerHandler {
    const VIEWER_ID: string

    function update(store: any, payload: any): void
  }

  export namespace graphql {
    const prototype: {}

    function experimental(strings: any): void

    namespace experimental {
      const prototype: {}
    }
  }
}
